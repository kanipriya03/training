1.SORT COLORS: 

void sortColors(int* nums, int numsSize){
    int temp;
    for(int i=0;i<numsSize;i++){
        for(int j=i+1;j<numsSize;j++){
            if(nums[i]>nums[j]){
                temp=nums[i];
                nums[i]=nums[j];
                nums[j]=temp;
            }
        }
    }
    for(int i=0;i<numsSize;i++){
        printf("%d",nums[i]);
    }
}

2.UNIQUE PATHS:

class Solution {
    public int uniquePaths(int m, int n) {
    int N=n+m-2;
    int r= m-1;
    double res=1;
    for(int i=1;i<=r;i++){
        res=res*(N-r+i)/i;
    }
    return (int)res;
    }
}
3.MAJORITY ELEMENTS: 

class Solution {
    public int majorityElement(int[] nums) {
        int count=0;
        int ele=0;
        for(int num:nums){
            if(count==0){
                ele=num;

            }
            if(num==ele)count+=1;
            else count-=1;
        }
        return ele;
        
    }
}

4.MAXIMUM CONSUQUTIVE ONES:

class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int count=0;
        int max=0;
        for(int i=0;i<nums.length;i++){
            if(nums[i]==1)
            count++;
            else
            count=0;
            max=Math.max(max,count);
        }
        return max;
        
    }
}
5.EDIT DISTANCE

int min(int a,int b,int c){
    return(a<=b)?(a<=c)?a:c:(b<=c)?b:c;
}

int minDistance(char * word1, char * word2){
    int m=strlen(word1);
    int n=strlen(word2);
    int edit[m+1][n+1];
    for(int i=0;i<=m;i++){
        for(int j=0;j<=n;j++){
            if(i==0){
                edit[i][j]=j;            
            }
            else if(j==0){
                edit[i][j]=i;
            }
            else if(word1[i-1]==word2[j-1]){
                edit[i][j]=edit[i-1][j-1];
            }
            else{
                edit[i][j]=1+min(edit[i][j-1],edit[i-1][j],edit[i-1][j-1]);
            }
        }
    }
    return edit[m][n];

}